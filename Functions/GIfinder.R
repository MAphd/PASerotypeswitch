##### PA7 GI finder
library(readr)
GIfinder <- function(Subject, Querydir, Filelist, Outputdir,Blasted){
# function(GIfinder )

  
#Function generates blast alignments against a subject genome (PA7 in this case). 
  #Using coordinates generated by BLAST alignment on subject (and query) the algorithm then checks if the serotype O12 cluster is found, by 
  # making sure the genomic coordinates 2002773 (GIleft) and 2028627 (GIright) are found in the alignment. 
  # If serotype o12 is found, then the algorithm attempts to find nearby high identity alignments in order to determine how much DNA is 
  # transfered from a PA7-like donor. In this case, "nearby" is determined by parameter "MaxGap" which is set to 1000 bp, and high identity
  # is >98% identity. Alignments under 100 bp are filtered out. 
  # The function returns a list per genome with blast table results, and a string containing which blast-table-result-rows were found for the serotype island
  # the length of the serotype island, and the coordinates of the serotype island, using the PA7 genome as reference for coordinates. 
  
## At minimum specify Outputdir and Blasted
  
  Outputdir <- dOutput
  
if( missing(Outputdir) ){
  stop("error, specify parameter Outputdir")
}
  
if( missing(Blasted) ){
    stop("error, specify parameter Blasted")
}
  
if( !missing(Filelist) ){
  Seqnms <- Filelist 
  
} else {
  
  if( !missing(Querydir) ){ 
  Seqnms <- list.files(Querydir)
  }
}
  
  
#If we dont have input genomes  
if( missing(Querydir) & missing(Filelist) ){
  Seqnms <- list.files(dOutput, pattern = "*.txt")
  Seqnms <- gsub("PA7GI_","",Seqnms)
  Blasted = TRUE
}
  
  
  
# Blasted <- TRUE

#Default parameters regarding serotype island in PA7
GIleft <- 2002773
GIright <- 2028627
MinALength <- 100
MinIdent <- 98
MaxGap <- 1000

# xyz <- 1
# Firstinput <- readline("Use default parameters? (y/n): ")
# 
# 
# 
# while( identical(xyz,1) ){
#   if(identical(Firstinput,"y")){
#     cat("Starting analysis using default parameters\n")
#     xyz <- 0
#   } else if(identical(Firstinput,"n")){
#     xyz2 <- 1
#     while(identical(xyz2,1)){
#       cat(paste0("1: Position of GI, left border = ",GIleft,
#                  "\n2: Position of GI, right border = ",GIright,
#                  "\n3: Minimum Alignment Length = ",MinALength,
#                  "\n4: Minimum identity = ",MinIdent,
#                  "\n5: Maximum Gap in alignment = ",MaxGap))
#       SecondInput <- readline("Specify which parameter to change (1-5), 0 to quit: ")
#       
#       
#       if(identical(as.numeric(SecondInput),0) ){
#         cat("Starting analysis: using specified parameters")
#         xyz2 <- 0
#         xyz <- 0
#       } else if(identical(as.numeric(SecondInput),1)){
#         
#         cat(paste0("1: Position of GI, left border, is currently ",GIleft))
#         Tempinput <- readline(prompt = "Set position of GI left border to: ")
#         if( !is.na(as.numeric(Tempinput)) ){
#           if( as.numeric(Tempinput) >= 0 ){
#             
#             GIleft <- as.numeric(Tempinput)
#           } else {
#             cat("Error: Wrong input, must be greater than, or 0\n\n")
#           }
#           
#         } else {
#           cat("Error: Wrong input, returning to start\n\n")
#         }
#         
#       } else if(identical(as.numeric(SecondInput),2)){
#         
#         cat(paste0("2: Position of GI, right border, is currently ",GIright))
#         Tempinput <- readline(prompt = "Set position of GI right border to: ")
#         if( !is.na(as.numeric(Tempinput)) ){
#           if( as.numeric(Tempinput) >= 0 ){
#             
#             GIright <- as.numeric(Tempinput)
#           } else {
#             cat("Error: Wrong input, must be greater than, or 0\n\n")
#           }
#           
#         } else {
#           cat("Error: Wrong input, returning to start\n\n")
#         }
#         
#       } else if(identical(as.numeric(SecondInput),3)){
#         cat(paste0("3: Minimum Alignment Length, is currently ",MinALength))
#         Tempinput <- readline(prompt = "Set Minimum Alignment Length to: ")
#         if( !is.na(as.numeric(Tempinput)) ){
#           if( as.numeric(Tempinput) >= 0 ){
#             
#             MinALength <- as.numeric(Tempinput)
#           } else {
#             cat("Error: Wrong input, must be greater than, or 0\n\n")
#           }
#           
#         } else {
#           cat("Error: Wrong input, returning to start\n\n")
#         }
#       } else if(identical(as.numeric(SecondInput),4)){
#         cat(paste0("4: Minimum identity, is currently ",MinIdent))
#         Tempinput <- readline(prompt = "Set Minimum identity to (between 95-99): ")
#         if( !is.na(as.numeric(Tempinput)) ){
#           if( as.numeric(Tempinput) >= 95 & as.numeric(Tempinput) <= 99 ){
#             
#             MinIdent <- as.numeric(Tempinput)
#           } else {
#             cat("Error: Wrong input, must be between 95 and 99\n\n")
#           }
#           
#         } else {
#           cat("Error: Wrong input, returning to start\n\n")
#         }
#       } else if(identical(as.numeric(SecondInput),5)){
#         cat(paste0("5: Maximum Gap in alignment, is currently ",MaxGap))
#         Tempinput <- readline(prompt = "Set Maximum gap to: ")
#         if( !is.na(as.numeric(Tempinput)) ){
#           if( as.numeric(Tempinput) >= 0 ){
#             
#             MaxGap <- as.numeric(Tempinput)
#           } else {
#             cat("Error: Wrong input, must be greater than, or 0\n\n")
#           }
#           
#         } else {
#           cat("Error: Wrong input, returning to start\n\n")
#         }
#         
#         
#       }
#     }
#     
#     
#   } else {
#     cat("Please input y or n\n\n")
#     Firstinput <- readline("Use default parameters? (y/n): ")
#     # xyz <- 0
#   }
# }
# 
# 
# 



#Borders at 2002773 to 2028627 
#total 6588339 




if(length(Seqnms)>=1){ 
  print( paste("Succesfully loaded ",length(Seqnms)," sequences", sep=""))
} else {
  
  stop("No input files could be loaded")
}


# Create commandline blastn commands for each subject file
# Cmdline <- function(Seqfile){
#   paste("blastn -query ", Input, Seqfile, " -subject ", OSAdb, " -out ",
#         Output, unlist(strsplit(Seqfile,".fasta")),
#         ".txt -outfmt ", "\"", "6 qaccver saccver pident sstart send length evalue bitscore", "\"" , sep="")
# 
# }


##### Include qstart qend, and ensure maxgap is also checked for query alignments (if on the same contig)
if( !Blasted ){
  
  Cmdline <- function(Seqfile){
    paste("blastn -query ", Querydir, Seqfile, " -subject ", Subject, " -out ",
          Outputdir, "PA7GI_", Seqfile,
          ".txt  -perc_identity ", MinIdent ," -outfmt ", "\"", "6 qaccver saccver pident sstart send length qstart qend evalue bitscore nident", "\"" ," -max_target_seqs 5000", sep="")
    
   }
  
  
  Cmds <- mapply(FUN = Cmdline, Seqfile = Seqnms) 
  
  # system(Cmds[1])
  #Run each blast colnames
  
  
  sapply(Cmds, system)
  
}
  
  # Blastnms <- paste("PA7GI_",Seqnms,".txt",sep="")
  

  # Blastnms <- paste("",Seqnms,".txt",sep="")
  
  Blastnms <- list.files(dOutput, pattern = "^PA7GI_")
  

GIlist <- list()
for(ji in 1:length(Blastnms)){   
  
  Data <- suppressMessages(data.frame(read_delim(paste(Outputdir, Blastnms,sep="")[ji], delim="\t",col_names = c("Queryacc","Subjacc","Identity","Sstart","Send","Length","Qstart","Qend","Evalue","Bitscore", "nident"))))
  
  
  
  #Purge low length alignments
  Data <- (Data[!(Data$Length<MinALength),])
  
  #Add a sense check first and flip everything to pos sense, then add a flag for anti sense /sense
  #Sense = 1 , antisense = 0
  
  Data$Sense <- as.numeric(Data$Sstart < Data$Send)
  
  
  for( ij in 1:dim(Data)[1]){
    #Rowwise, flip sstart and ssend if data$sense is equal to 0
    TempVar1 <- cbind(Data$Sstart[ij], Data$Send[ij]  )
    
    if( !identical(Data$Sense[ij],1) ){
      Data$Sstart[ij] <- TempVar1[2]
      Data$Send[ij] <- TempVar1[1]
      
    }
    
    
  }
  rm(TempVar1)
  rm(ij)
  
  
  #Reorder, by Sstart and Evalue
  WorkingD <- Data[c(order(Data$Sstart,Data$Bitscore)),]
  
  #Define query sense
  WorkingD$Qsense <- WorkingD$Qstart < WorkingD$Qend
  
  # test <- WorkingD
  # WorkingD <- test
  
  
  ###Check if there are overlaps between any of the alignments, and remove alignments that are completely overshadowed
  y <- 1 
  # a <- 0
  while(identical(y,1)){ 
    
    if( identical(dim(WorkingD)[1],as.integer(1)) ){
      break
    }
    # for(zjzjzj in 1:62){ 
    OLvect2 <- c()
    # dMat <- 0
    for(i in 1:(length(WorkingD$Length)-1)){
      
      #Is sequence I's end within 1000 bps of Sequence i+1's start? 
      # OLcheck <- abs(WorkingD$Send[i]-WorkingD$Sstart[i+1])<1000 
      OLcheck <- 0
      if( WorkingD$Send[i] >= WorkingD$Send[i+1]){
        OLcheck <- 2  #Type 2 overlap is when a given alignment covers the entirety of another alignment
      } else if( WorkingD$Send[i] >= WorkingD$Sstart[i+1]  ){
        OLcheck <- 1 #Type 1 alignment is when an alignment only partially covers another alignment 
      } 
      
      OLvect2 <- c(OLvect2, OLcheck )
    }
    
    if( any( OLvect2 == 2 )){
      #Remove type 2 overlaps in such a way that the longest alignment is favoured (which is closer to the top, 
      # since they are sorted by sstart, then bitscore)
      WorkingD <- WorkingD[-(which( (OLvect2 == 2))+1),]
    } else {
      y <- 0
      break
    }
    
    
    
    # }
    
    # a <- a+1
  }
  
  
  
  
  ### Check which sequences have positions GIleft and GIright, and build OLvect from these? would save a lot of time
  OLvect3 <- data.frame()
  for(i in 1:(length(WorkingD$Length))){
    
    OLvect3 <- 
      rbind(OLvect3, 
            cbind(
              ( (WorkingD$Sstart[i] < GIleft) & (WorkingD$Send[i] > GIleft) ),
             ((GIright > WorkingD$Sstart[i]) & (GIright < WorkingD$Send[i] ))
              
            ))
    
    
  }
  
  #Here we wish to determine the bare minimum of a serotype island (Between GIleft and GIright)
  #Presence of true in both coloumns of OLvect3 means we can find the serotype island (probably)  
  GIland <- FALSE
  if( ((any(OLvect3[,1])) & (any(OLvect3[,2]))) ){
    
    
    #Since we have organized the alignments in order of Sstart, we search from "left" to "right" from the GIleft result
    a <- which(OLvect3[,1])
    b <- which(OLvect3[,2])
    
    #They are contained on the same alignment
    if( identical(a,b) ){
      
      GIland <- TRUE
      
    } else { 
      #They are contained on different alignments, and we need to determine if these map close enough together
      
      
      j <- 0
      y <- 1
      while(identical(y,1)){
        
        #Start by making sure there exists an alignment +1 to "a"
        
        if(a+j+1 <= length(OLvect3[,1]) ){
          aba <- abs(WorkingD$Send[a+j]-WorkingD$Sstart[a+1+j])<MaxGap
          if( identical(WorkingD$Queryacc[a+j],WorkingD$Queryacc[a+j+1]) ){
          aba2 <- abs(WorkingD$Qend[a+j]-WorkingD$Qstart[a+1+j])<MaxGap #Only relevant for queries where the GI is on a single contig, assuming plasmid elements don't appear here
          # aba
          } else { aba2 <- TRUE } #For fragmented genomes (multiple contigs), we can't do above check, so it is ignored
          aba <- all(aba,aba2)
          if( aba ){
            j <- j + 1
          } else {
            y <- 0
          }
          
        } else {
          y <- 0
        }
        
        #Stop when we connect a and b
        if( identical((a + j),as.numeric(b))  ){
          y <- 0
        }
        
      }
      
      #If j equals b-a that means we can "assemble" alignments between alignments since they are within our maxgap threshold. 
      if( identical(as.numeric(j),as.numeric(b-a) ) ){
        
        
        GIland <- TRUE
        
      }
      
    }
    
    
    
    
    
  }
  
  #We have a serotype island, time to find out how far we can stretch it.
  if( GIland ){
    
    y <- 1
    j1 <- 0
    #Left side stretch
    while( identical(y,1) ){
      #Does a "-1" alignment exist to a-j1
      if( 1<=((a+j1)-1) ){
        if( (abs(WorkingD$Sstart[a+j1]-WorkingD$Send[a+j1-1])<MaxGap) ){
          
          if( identical(WorkingD$Queryacc[a+j1],WorkingD$Queryacc[a+j1-1]) ){ #The query location parameters are only relevant for alignments on the same contig
            # if( (abs(WorkingD$Qstart[a+j1]-WorkingD$Qend[a+j1-1])<MaxGap) ){
            if( (abs(max(WorkingD$Qstart[a+j1],WorkingD$Qend[a+j1])-min(WorkingD$Qstart[a+j1-1],WorkingD$Qend[a+j1-1]))<MaxGap) ) {   
              j1 <- j1-1
              
              
            } else {
              y <- 0
            }
            
          } else {  # the a-j1-1 alignment is not on the same contig as a-j1, so we will just assume we can "strech" it
            j1 <- j1-1
            }
          
          
          
        } else {
          y <- 0
        }
      } else {
        y <- 0
      }
    }
    
    y <- 1
    j2 <- 0
    #Right side stretch
    while( identical(y,1) ){
      #Does a "+1" alignment exist to b+j2
      if( length(WorkingD$Length) >= ((b+j2)+1) ){
        if( (abs(WorkingD$Send[b+j2]-WorkingD$Sstart[b+j2+1])<MaxGap) ){
          
          if( identical(WorkingD$Queryacc[b+j2],WorkingD$Queryacc[b+j2+1]) ){ 
            # if( (abs(WorkingD$Qend[b+j2]-WorkingD$Qstart[b+j2+1])<MaxGap) ){
            if( (abs(max(WorkingD$Qstart[b+j2],WorkingD$Qend[b+j2])-min(WorkingD$Qstart[b+j2+1],WorkingD$Qend[b+j2+1]))<MaxGap) ){ 
              j2 <- j2+1
            } else {
              y <- 0
            }
            
          } else {
            j2 <- j2+1
          }
          
          
        } else {
          y <- 0
        }
      } else {
        y <- 0
      }
    }
    
    
    
    
    WorkingD <- WorkingD[c(seq(a+j1,b+j2,1)),]
    
    
    GIlist[[ Seqnms[ji] ]][[1]] <- c(paste( c(seq(a+j1,b+j2,1)) ,collapse="."), sum(WorkingD$Length), min(WorkingD$Sstart) , max(WorkingD$Send)  )
    GIlist[[ Seqnms[ji] ]][[2]] <- WorkingD
    
    
  }
  
  
  
    
    
    
    
  #  ######## old  
  # #Here we are discounting every single sequence alignment .. 
  # #Attempt to create assemblies with a maximum gapped sequence of 1000 bp
  # OLvect <- c()
  # # dMat <- 0
  # for(i in 1:(length(WorkingD$Length))-1){
  #   
  #   #Is sequence I's end within 1000 bps of Sequence i+1's start? 
  #   # abs(WorkingD$Send[i]-WorkingD$Sstart[i+1])
  #   
  #   OLvect <- c(OLvect, abs(WorkingD$Send[i]-WorkingD$Sstart[i+1])<MaxGap  )
  # }
  # 
  # 
  # #Go through OLvect and find "stretches" of true, returning a vector of indexes into a list
  # 
  # 
  # #Rewrite entire section so it can handle both single alignments and overlap alignments. perhaps even start by checking single alignments, then 
  # #if any of these contain serotype island, try to assemble alignments
  # 
  # 
  # OLvect <- (which(OLvect))
  # 
  # 
  # 
  # 
  # 
  # OLMat <- c()
  # OLcheck <- as.character()
  # z <- 1 
  # # OLlist <- list()
  # xy <- 0
  # for(i in 1:(length(OLvect))){
  #   # print(xy)
  #   
  #   
  #   # if( OLvect[i] ){}
  #   
  #   if(xy !=0 ){
  #     xy <- xy-1
  #     next
  #   }
  #   
  #   # if( OLcheck[i] )
  #   
  #   
  #   if( identical(as.numeric(OLvect[i+1])-1,as.numeric(OLvect[i])) ){
  #     
  #     OLcheck <- as.character(paste0(OLvect[i],".",OLvect[i+1]))
  #     j <- i
  #     y <- 1
  #     while( identical(y,1) ){
  #       j <- j+1
  #       if( identical(as.numeric(OLvect[j+1])-1,as.numeric(OLvect[j])) ){
  #         OLcheck <- paste0( OLcheck,".",OLvect[j+1]) 
  #         xy <- xy+1
  #       } else {
  #         OLcheck <- paste0( OLcheck,".",as.numeric(unlist(strsplit(OLcheck,".",fixed=TRUE)))[length(unlist(strsplit(OLcheck,".",fixed=TRUE)))]+1)
  #         xy <- xy+1
  #         y <- 0
  #         # break
  #       }
  #       
  #     }
  #     
  #     
  #   } else {
  #     OLcheck <- paste0(OLvect[i],".",OLvect[i]+1)
  #     # next
  #     # xy <- xy+1
  #   }
  #   
  #   # OLcheck <- paste0(OLcheck,".",as.numeric(unlist(strsplit(OLcheck,".",fixed=TRUE)))[length(unlist(strsplit(OLcheck,".",fixed=TRUE)))]+1 )
  #   
  #   
  #   
  #   
  #   #Save everything
  #   # OLlist[[z]] <- c( OLcheck,
  #   #                   as.character(sum(WorkingD$Length[c(as.numeric(unlist(strsplit(OLcheck,".",fixed=TRUE))))])), #Total length of potential GI
  #   #                   ( WorkingD$Sstart[as.numeric(unlist(strsplit(OLcheck,".",fixed=TRUE)))[1]] <= 2002773 &
  #   #                       WorkingD$Send[ as.numeric(unlist(strsplit(OLcheck,".",fixed=TRUE)))[length(unlist(strsplit(OLcheck,".",fixed=TRUE)))] ] >= 2028627 )#Does it contain serotype island?
  #   # )
  #   # 
  #   # # OLlist[[z]] 
  #   # z <- z+1
  #   
  #   #Only save if it contains serotype island
  #   if( WorkingD$Sstart[as.numeric(unlist(strsplit(OLcheck,".",fixed=TRUE)))[1]] <= GIleft &
  #       WorkingD$Send[ as.numeric(unlist(strsplit(OLcheck,".",fixed=TRUE)))[length(unlist(strsplit(OLcheck,".",fixed=TRUE)))] ] >= GIright  ){
  #     # OLlist[[z]] <- c(OLcheck,
  #     #                  as.character(sum(WorkingD$Length[c(as.numeric(unlist(strsplit(OLcheck,".",fixed=TRUE))))])) )
  #     
  #     #Opens up for more results per genome, for now we're only interested in serotype islands
  #     # OLMat <- (rbind(OLMat, c(OLcheck,
  #     #                as.character(sum(WorkingD$Length[c(as.numeric(unlist(strsplit(OLcheck,".",fixed=TRUE))))])),
  #     #                as.character(WorkingD$Sstart[as.numeric(unlist(strsplit(OLcheck,".",fixed=TRUE)))[1]]),
  #     #                as.character(WorkingD$Send[ as.numeric(unlist(strsplit(OLcheck,".",fixed=TRUE)))[length(unlist(strsplit(OLcheck,".",fixed=TRUE)))] ])
  #     #                )))
  #     OLMat <- c(OLMat, OLcheck,
  #                               as.character(sum(WorkingD$Length[c(as.numeric(unlist(strsplit(OLcheck,".",fixed=TRUE))))])),
  #                               as.character(WorkingD$Sstart[as.numeric(unlist(strsplit(OLcheck,".",fixed=TRUE)))[1]]),
  #                               as.character(WorkingD$Send[ as.numeric(unlist(strsplit(OLcheck,".",fixed=TRUE)))[length(unlist(strsplit(OLcheck,".",fixed=TRUE)))] ])
  #                               )
  #     z <- z+1
  #     
  #     
  #   }
  #   
  # }
  # 
  # # GIlist[[ji]] <- ((OLlist))
  # 
  # #Check if is null, probably since the GI wasn't found. 
  # 
  # if( !is.null(OLMat)){
  # GIlist[[ Seqnms[ji] ]][[1]] <- OLMat
  # GIlist[[ Seqnms[ji] ]][[2]] <- WorkingD[as.numeric(unlist(strsplit(OLMat[1],".",fixed=TRUE))),]
  # }
} 

# ( WorkingD$Sstart[as.numeric(unlist(strsplit(OLcheck,".",fixed=TRUE)))[1]] <= 2002773 &
# WorkingD$Send[ as.numeric(unlist(strsplit(OLcheck,".",fixed=TRUE)))[length(unlist(strsplit(OLcheck,".",fixed=TRUE)))] ] >= 2028627 )


# test <- readline("Only plot? (y/n): ")

GIlist
}

#Create plots w  karyoploteR  
# 
# if (!requireNamespace("BiocManager", quietly = TRUE))
#   install.packages("BiocManager")
# 
# BiocManager::install("karyoploteR")
# 
# browseVignettes("karyoploteR")

# library("karyoploteR")
# 
# ?plotKaryotype
# 
# 
# install.packages("rlang")
# install.packages("xfun")


# detach_package("BSgenome", TRUE)


#Write a function to do this based on GIlist output

# ggplot() +
#   # geom_polygon(x=c(1,10),y=c(0,1))
#   # geom_polygon()
#   # geom_line()
#   geom_segment(aes(x = 1981831, y = 1.2 , xend= 2029243, yend= 1.2, size = 1), colour = "Black") + #ARA02-029
#   geom_text(aes(x=1970000,y=1.2),label="ST111") +
#   geom_segment(aes(x = 1981772, y = 1.3 , xend= 2029243, yend= 1.3, size = 1), colour = "Black") + #CAN01-003
#   geom_text(aes(x=1970000,y=1.3),label="ST111") +
#   geom_segment(aes(x = 1982188, y = 1.4 , xend= 2032432, yend= 1.4, size = 1), colour = "Black") + #MAD05-041
#   geom_text(aes(x=1970000,y=1.4),label="ST111") +
#   geom_segment(aes(x = 1982188, y = 1.5 , xend= 2029243, yend= 1.5, size = 1), colour = "Black") + #NAV01-012
#   geom_text(aes(x=1970000,y=1.5),label="ST111") +
#   geom_segment(aes(x = 1981338, y = 1.6 , xend= 2029239, yend= 1.6, size = 1), colour = "Black") + #PVA01-021
#   geom_text(aes(x=1970000,y=1.6),label="ST111") +
#   geom_segment(aes(x = 1981755, y = 1.7 , xend= 2029243, yend= 1.7, size = 1), colour = "Black") + #CAT05-008
#   geom_text(aes(x=1970000,y=1.7),label="ST111") +
#   geom_segment(aes(x = 1982172, y = 1.8 , xend= 2029243, yend= 1.8, size = 1), colour = "Black") + #CAT09-026
#   geom_text(aes(x=1970000,y=1.8),label="ST111") +
#   geom_segment(aes(x = 1975112, y = 1.9 , xend= 2029239, yend= 1.9, size = 1), colour = "Black") + #CAT04-016
#   geom_text(aes(x=1970000,y=1.9),label="ST253") +
#   geom_segment(aes(x = 1981736, y = 2. , xend= 2029239, yend= 2., size = 1), colour = "Black") + #CAT09-027
#   geom_text(aes(x=1970000,y=2.),label="ST253") +
#   geom_segment(aes(x = 1981736, y = 2.1 , xend= 2029239, yend= 2.1, size = 1), colour = "Black") + #CAT09-027
#   geom_text(aes(x=1970000,y=2.1),label="ST253") +
#   geom_segment(aes(x = 1974169, y = 2.2 , xend= 2207756, yend= 2.2, size = 1), colour = "Black") + #CVA03-004
#   geom_text(aes(x=1970000,y=2.2),label="ST244") +
# 
#   geom_segment(aes(x = 0, y = 1 , xend= 6588339, yend= 1, size = 1), colour = "Black") + #PA7
#   geom_text(aes(x=1970000,y=1.05),label="PA7") +
#   # geom_segment(aes(x = GIleft, y = 3 , xend= GIleft, yend= 1, size = 1,alpha=0.5), colour = "Black") + #ARA02-029
#   # geom_text(aes(x=1700000,y=1.2),label="ST111") +
#   # geom_polygon(aes(x=c(GIleft,GIright,GIleft,GIright),y=c(0,3,0,3),size=1),fill="Black") +
#   geom_rect(aes(xmin=GIleft,xmax=GIright,ymin=0.98,ymax=3),alpha=0.3,fill="green") +
#   geom_rect(aes(xmin=1980787,xmax=1981947,ymin=0.98,ymax=3),alpha=0.3,fill="red") +
#   geom_rect(aes(xmin=1973779,xmax=1975143,ymin=0.98,ymax=3),alpha=0.3,fill="blue") +
#   geom_rect(aes(xmin=2030742,xmax=2032754,ymin=0.98,ymax=3),alpha=0.3,fill="yellow") +
#   geom_rect(aes(xmin=2029290,xmax=2029215,ymin=0.98,ymax=3),alpha=0.2,color="black",fill="black") +
#   theme(axis.title.y=element_blank(),
#         axis.text.y=element_blank(),
#         axis.ticks.y = element_blank()) +
#   coord_cartesian(xlim=c(1970000,2040000),ylim=c(1,2.2)) 
  # scale_size_manual(guide="none")

    # ylim(c(-15,15)) 

#rluB
#1980787..1981947

#oprB
#1973779..1975143

#uvrB
# 2030742..2032754

#tRNA-asn
#2029290  2029215








